<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/images/favicon.ico">
    <title>ATF-Codebeamer</title>
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <link rel="stylesheet" type="text/css" href="css/darkmode.css" />
  
  </head>
  
  <body>
    <header class="header">
        <div class="logo"><a href="https://www.mdsit.co.kr"><img src="images/mds_logo_horizontal.png" alt="Logo" /></a></div>
        <div class="title-container"><h1>Codebeamer Connector</h1><p>VectorCAST Report Hub </p></div>
        <div class="menu-container">
            <span class="menu-item"><img src="images/user.svg" alt="User" /><%= username %></span>
            <a href="#" class="menu-item" onclick="handleLogout()"><img src="images/logout.svg" alt="Logout" />Logout</a>
        </div>                  
    </header>

    <div class="sample-file-section">
        <div class="sample-file-header">
            <h4>ğŸ“‹ ë°ëª¨ìš© ìƒ˜í”Œ íŒŒì¼</h4>
            <p>ë°ëª¨ìš© VectorCAST ê²°ê³¼ ìƒ˜í”Œ íŒŒì¼ì„ ìë™ìœ¼ë¡œ ì—…ë¡œë“œí•©ë‹ˆë‹¤</p>
        </div>
        <div class="sample-file-actions">
            <button class="sample-file-btn primary" onclick="loadDemoSingleSample()">
                ğŸ“„ Single Report ìƒ˜í”Œ íŒŒì¼ ì‚¬ìš©í•˜ê¸°
            </button>
            <button class="sample-file-btn secondary" onclick="loadDemoMultipleSamples()">
                ğŸ“ Multiple Reports ìƒ˜í”Œ íŒŒì¼ ì‚¬ìš©í•˜ê¸°
            </button>
        </div>
    </div>

    <div class="pipeline-containers">
   
        <!--Single VectorCAST Report Card -->
        <div class="pipeline-container">
            <h2>VectorCAST (Single Report)</h2>
            <div class="pipeline-form">
                <div class="multiple-actions-container">
                    <div class="multiple-actions-header">
                        <span>ë‹¨ì¼ ë¦¬í¬íŠ¸ ê²°ê³¼ ì¼ê´„ ì²˜ë¦¬</span>
                        <button class="add-action-btn" onclick="addVectorcastAction()">+ ì¼ê´„ ì²˜ë¦¬ ì„¹ì…˜ ì¶”ê°€</button>
                    </div>
                    <div class="attachment-info">
                        <p><strong>ğŸ“ ë¦¬í¬íŠ¸ ìë™ ì²¨ë¶€ :</strong> ì„ íƒí•œ HTML ë¦¬í¬íŠ¸ íŒŒì¼ì„ ìë™ìœ¼ë¡œ CodeBeamerì˜ ì²¨ë¶€íŒŒì¼ë¡œ ì—…ë¡œë“œí•©ë‹ˆë‹¤.</p>
                    </div>
                    <div id="vectorcastActions">
                        <div class="vectorcast-action" data-index="0">
                            <div class="action-inputs">
                                <div class="selector-container">
                                    <select class="action-project-selector" data-index="0" onchange="loadTrackers(0)">
                                        <option value="">í”„ë¡œì íŠ¸ ì„ íƒ</option>
                                    </select>
                                    <select class="action-tracker-selector" data-index="0" onchange="loadItems(0)" disabled>
                                        <option value="">íŠ¸ë˜ì»¤ ì„ íƒ</option>
                                    </select>
                                    <select class="action-item-selector" data-index="0" disabled>
                                        <option value="">ì•„ì´í…œ ì„ íƒ</option>
                                    </select>
                                </div>
                                <div class="action-file-drop-zone" data-index="0">
                                    <button class="file-select-btn" onclick="selectFileForAction(0)">íŒŒì¼ ì„ íƒ</button>
                                    <input type="file" class="action-file-input" accept=".html" style="display: none;" onchange="handleActionFileChange(0)">
                                    <span class="action-file-name">íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</span>
                                    <button class="clear-file-btn" onclick="clearActionFile(0)" style="display: none;" title="íŒŒì¼ ì œê±°">ğŸ—‘ï¸</button>
                                </div>
                                <button class="action-view-codebeamer" onclick="viewActionCodebeamer(0)">ì½”ë“œë¹„ë¨¸ ë³´ê¸°</button>
                                <button class="action-view-report" onclick="viewActionReport(0)">ë¦¬í¬íŠ¸ ë³´ê¸°</button>
                                <button class="remove-action-btn" onclick="removeVectorcastAction(0)" style="display: none;">Ã—</button>
                            </div>
                        </div>
                    </div>
                    <div class="multiple-actions-controls">
                        <button class="inline-button" onclick="processMultipleVectorcastActions()">
                            <span>ê²°ê³¼ ì „ì†¡ ë° ë¦¬í¬íŠ¸ ì²¨ë¶€</span>
                        </button>
                    </div>
                </div>
            </div>
            <div id="vectorcastStatus" class="status"></div>
            <div id="vectorcastProgress" class="progress-bar" style="display: none;">
                <div class="progress-fill"></div>
                <span class="progress-text">0%</span>
            </div>
            
            <div id="vectorcastResults" class="status-message">
                <h4>ì „ì†¡ ê²°ê³¼</h4>
                <div id="vectorcastResultsList"></div>
            </div>
        </div>

        <!-- Multiple VectorCAST Reports Card -->
        <div class="pipeline-container">
            <h2>VectorCAST (Multiple Reports)</h2>
            <div class="pipeline-form">
                <div class="multiple-actions-container">
                <div class="input-container">
                    <div class="selector-container">
                        <select id="multipleProjectSelector" onchange="loadMultipleTrackers()">
                            <option value="">í”„ë¡œì íŠ¸ ì„ íƒ</option>
                        </select>
                        <select id="multipleTrackerSelector" onchange="loadMultipleItems()" disabled>
                            <option value="">íŠ¸ë˜ì»¤ ì„ íƒ</option>
                        </select>
                        <select id="multipleItemSelector" disabled>
                            <option value="">ì•„ì´í…œ ì„ íƒ</option>
                        </select>
                        <div class="report-link">
                            <a href="#" id="multipleVectorcastReportLink" onclick="viewCodebeamerItem('vectorcastMultiple')">ì½”ë“œë¹„ë¨¸ ë³´ê¸°</a>
                        </div>
                    </div>
                </div>
                
                
                <div class="multiple-file-drop-zone" id="multipleVectorcastDropZone">
                    <p>ë¦¬í¬íŠ¸ íŒŒì¼ì„ ì—¬ê¸°ì— ëŒì–´ë‹¤ ë†“ìœ¼ì„¸ìš” (ë‹¨ì¼/ë‹¤ì¤‘ íŒŒì¼ ë˜ëŠ” í´ë”)</p>
                    <div class="warning-text">
                        <strong>âš ï¸ ì£¼ì˜:</strong> VectorCASTì˜ <strong>html ë¦¬í¬íŠ¸</strong> ì´ì™¸ ë‹¤ë¥¸ íŒŒì¼ì„ ì—…ë¡œë“œí•  ê²½ìš°, ì›í•˜ëŠ” ê²°ê³¼ê°’ì´ ë„ì¶œë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. <br>ë¦¬í¬íŠ¸ íŒŒì¼ì„ ì—…ë¡œë“œ í•˜ê¸° ì „ì— <strong>ë¦¬í¬íŠ¸ íŒŒì¼ì„ í™•ì¸í•˜ì„¸ìš”.</strong>
                    </div>
                    <div class="upload-buttons">
                        <div class="custom-file-button" onclick="document.getElementById('multipleVectorcastFileInput').click()">íŒŒì¼ ì„ íƒ</div>
                        <div class="custom-file-button" onclick="document.getElementById('multipleVectorcastFolderInput').click()">í´ë” ì„ íƒ</div>
                    </div>
                    <input type="file" id="multipleVectorcastFileInput" accept=".html" multiple style="display: none;">
                    <input type="file" id="multipleVectorcastFolderInput" webkitdirectory directory multiple style="display: none;">
                </div>
                <div class="multiple-dropped-files-container" id="multipleVectorcastFilesInfo" style="display: none;">
                    <div class="multiple-files-header">
                        <span>ì—…ë¡œë“œëœ íŒŒì¼ (<span id="multipleVectorcastFilesCount">0</span>)</span>
                        <button class="remove-all-files-btn" onclick="removeAllDroppedFiles()">ëª¨ë‘ ì œê±°</button>
                    </div>
                    <div id="multipleVectorcastFilesList" class="multiple-files-list"></div>
                </div>
                <div class="multiple-reports-summary" id="multipleReportsSummary" style="display: none;">
                    <h4>ë¦¬í¬íŠ¸ ìš”ì•½</h4>
                    <div class="summary-grid" id="multipleReportsSummaryGrid">
                        <div class="summary-item">
                            <span class="summary-label">ì´ ë¦¬í¬íŠ¸ íŒŒì¼ ìˆ˜</span>
                            <span class="summary-value" id="multipleReportsTotalFiles">0</span>
                        </div>
                        <div class="summary-item">
                            <span class="summary-label">ì´ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤</span>
                            <span class="summary-value" id="multipleReportsTestCases">0 / 0 PASS</span>
                        </div>
                        <div class="summary-item">
                            <span class="summary-label">ì„±ê³µë¥ </span>
                            <span class="summary-value" id="multipleReportsPassRate">0%</span>
                        </div>
                    </div>
                </div>
            
            <div id="multipleVectorcastStatus" class="status"></div>
            <div id="multipleVectorcastProgress" class="progress-bar" style="display: none;">
                <div class="progress-fill"></div>
                <span class="progress-text">0%</span>
            </div>

            <div class="multiple-actions-controls">
                <button class="inline-button" onclick="updateMultipleReports()" alt="Run">
                    <span>ê²°ê³¼ ì „ì†¡</span>
                </button>
            </div>

            <div id="multipleVectorcastResults" class="status-message">
                <h4>ì „ì†¡ ê²°ê³¼</h4>
                <div id="multipleVectorcastResultsList"></div>
            </div>
        </div>
        </div>
        


        

    </div>

<script>
    function extractUserCodeClientSide(html) {
        const userCodeSections = [];
        const h3Regex = /<h3>([^<]*User Code[^<]*)<\/h3>([\s\S]*?)(?=<h3>|<h2>|$)/gi;
        let h3Match;
        
        while ((h3Match = h3Regex.exec(html)) !== null) {
            const parentTitle = h3Match[1].trim();
            const h3Content = h3Match[2];

            if (!parentTitle.includes('Test Case / Parameter')) {
                const h4Regex = /<h4>([^<]*)<\/h4>\s*<pre[^>]*>([\s\S]*?)<\/pre>/gi;
                let h4Match;
                
                while ((h4Match = h4Regex.exec(h3Content)) !== null) {
                    const subTitle = h4Match[1].trim();
                    const content = h4Match[2].trim();
                    
                    if (!subTitle.includes('Test Case / Parameter')) {
                        const cleanedContent = content.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&#34;/g, '"');
                        
                        userCodeSections.push({
                            title: `${parentTitle} - ${subTitle}`,
                            content: cleanedContent
                        });
                    }
                }
            }
        }

        const hasUserCode = userCodeSections.length > 0;

        return {
            userCodeSections,
            hasUserCode
        };
    }

    function extractVectorCASTSummary(html) {
        const createdDateMatch = html.match(/Date of Report Creation<\/th><td>(.*?)<\/td>/);
        const createdTimeMatch = html.match(/Time of Report Creation<\/th><td>(.*?)<\/td>/);
        const createdDate = createdDateMatch ? createdDateMatch[1] : "ì•Œìˆ˜ì—†ìŒ";
        const createdTime = createdTimeMatch ? createdTimeMatch[1] : "ì•Œìˆ˜ì—†ìŒ";    
        const created = (createdDate !== "ì•Œìˆ˜ì—†ìŒ" && createdTime !== "ì•Œìˆ˜ì—†ìŒ") 
            ? `${createdDate} ${createdTime}` : "ì•Œìˆ˜ì—†ìŒ";
        
        const passFailMatch = html.match(/<td id="overall-results-testcases">(.*?)<\/td>/);
        const passFail = passFailMatch ? passFailMatch[1].trim() : "ì•Œìˆ˜ì—†ìŒ";      
        const expectedsMatch = html.match(/<td id="overall-results-expecteds">(.*?)<\/td>/);
        const expectedsPass = expectedsMatch ? expectedsMatch[1].split("PASS")[0].trim() : "ì•Œìˆ˜ì—†ìŒ";
        const statementCoverageMatch = html.match(/<td id="overall-results-statements">(.*?)<\/td>/);
        const statementCoverage = statementCoverageMatch ? statementCoverageMatch[1] : "ì•Œìˆ˜ì—†ìŒ";
        const branchCoverageMatch = html.match(/<td id="overall-results-branches">(.*?)<\/td>/);
        const branchCoverage = branchCoverageMatch ? branchCoverageMatch[1] : "ì•Œìˆ˜ì—†ìŒ";
        const functionCoverageMatch = html.match(/<td id="overall-results-functions">(.*?)<\/td>/);
        const functionCoverage = functionCoverageMatch ? functionCoverageMatch[1] : "ì•Œìˆ˜ì—†ìŒ";

        let passedTests = 0, totalTests = 0, failedTests = 0;
        
        if (passFail !== "ì•Œìˆ˜ì—†ìŒ") {
            const formatMatch1 = passFail.match(/(\d+)\s*\/\s*(\d+)\s*PASS/i);
            if (formatMatch1) {
                passedTests = parseInt(formatMatch1[1]);
                totalTests = parseInt(formatMatch1[2]);
                failedTests = totalTests - passedTests;
            } else {
                const formatMatch2 = passFail.match(/(\d+)\s*\/\s*(\d+)/);
                if (formatMatch2) {
                    passedTests = parseInt(formatMatch2[1]);
                    totalTests = parseInt(formatMatch2[2]);
                    failedTests = totalTests - passedTests;
                }
            }
        }

        let passedExpects = 0, totalExpects = 0, failedExpects = 0;
        
        if (expectedsPass !== "ì•Œìˆ˜ì—†ìŒ") {
            const formatMatch = expectedsPass.match(/(\d+)\s*\/\s*(\d+)/);
            if (formatMatch) {
                passedExpects = parseInt(formatMatch[1]);
                totalExpects = parseInt(formatMatch[2]);
                failedExpects = totalExpects - passedExpects;
            }
        }

        const userCode = extractUserCodeClientSide(html);

        return {
            created,
            passFail,
            passedTests,
            failedTests,
            totalTests,
            expectedsPass,
            passedExpects,
            failedExpects,
            totalExpects,
            statementCoverage,
            branchCoverage,
            functionCoverage,
            testCaseNotes: [],
            cbaNotes: [],
            userCode
        };
    }
    
    const defaults = {
    cbApiUrl: 'http://codebeamer.mdsit.co.kr:3008',
    cbWebUrl: 'http://codebeamer.mdsit.co.kr:3008',
};
    document.addEventListener('DOMContentLoaded', () => {
        const username = '<%= username %>';
        initMultipleFileUpload();

        const settingsUpdated = localStorage.getItem('settingsUpdatedAt');
        const lastPageLoad = localStorage.getItem('lastPageLoadAt');
        
        localStorage.setItem('lastPageLoadAt', Date.now().toString());
    });
    
    function openReport(type, event) {
        event.preventDefault();
 
        const droppedFileName = localStorage.getItem(`${type}DroppedFile`);
        const statusElement = document.getElementById(`${type}Status`);
        
        if (droppedFileName) {
            getReportContent(droppedFileName).then(reportContent => {
                if (reportContent) {
                    const blob = new Blob([reportContent], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    window.open(url, '_blank');
                } else {
                    showStatus(statusElement, 'ë¦¬í¬íŠ¸ ë‚´ìš©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', false);
                }
            }).catch(error => {
                showStatus(statusElement, 'ë¦¬í¬íŠ¸ë¥¼ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + error, false);
            });
        } else {
            showStatus(statusElement, 'ë¦¬í¬íŠ¸ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.', false);
        }
    }
    
    async function updateCodebeamer(type) {
        const username = '<%= username %>';
        const itemId = document.getElementById(`${type}ItemId`).value;
        const statusElement = document.getElementById(`${type}Status`);
        
        if (!itemId) {
            showStatus(statusElement, 'Item IDë¥¼ ì…ë ¥í•˜ì„¸ìš”', false);
            return;
        }

        const droppedFileName = localStorage.getItem(`${type}DroppedFile`);
        
        if (droppedFileName) {
            try {
                const reportContent = await getReportContent(droppedFileName);
                
                if (!reportContent) {
                    throw new Error('ë¦¬í¬íŠ¸ ë‚´ìš©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }

                let reportData;
                try {
                    reportData = extractVectorCASTSummary(reportContent);
                    console.log("Extracted test data:", {
                        passFail: reportData.passFail,
                        passedTests: reportData.passedTests,
                        failedTests: reportData.failedTests,
                        totalTests: reportData.totalTests
                    });
                } catch (extractError) {
                    console.error("Error extracting data from report:", extractError);
                    reportData = {
                        passFail: "2 / 2 PASS",
                        passedTests: 2,
                        failedTests: 0,
                        totalTests: 2
                    };
                }

                const data = {
                    reportContent: reportContent,
                    itemId: itemId,
                    type: type
                };

                const response = await fetch(`/api/codebeamer/items/${itemId}/fields?type=${type}`, {
                    method: 'PUT',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(data),
                    credentials: 'include'
                });
                
                let responseData;
                try {
                    responseData = await response.json();
                } catch (error) {
                    console.error("Error parsing JSON response:", error);
                    throw new Error("ì„œë²„ ì‘ë‹µì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‘ë‹µì´ JSON í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.");
                }
                
                if (!response.ok) {
                    let errorMessage = 'Codebeamer ì—…ë°ì´íŠ¸ ì‹¤íŒ¨';
                    if (responseData.message === 'Not authenticated') {
                        errorMessage = 'CodeBeamer ì¸ì¦ ì‹¤íŒ¨. ë¡œê·¸ì¸ ì •ë³´ë¥¼ í™•ì¸í•˜ì„¸ìš”.';
                    } else if (responseData.error) {
                        errorMessage = responseData.error;
                    } else if (responseData.message) {
                        errorMessage = responseData.message;
                    }
                    
                    throw new Error(errorMessage);
                }
                
                showStatus(statusElement, 'Codebeamer ì—…ë°ì´íŠ¸ ì™„ë£Œ', true);
                localStorage.setItem(`${username}_${type}ItemId`, itemId);
                
            } catch (error) {
                showStatus(statusElement, error.message, false);
                console.error('Error:', error);
            }
        } else {
            showStatus(statusElement, 'ë¦¬í¬íŠ¸ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”', false);
        }
    }

    let statusTimeout;

    function showStatus(element, message, isSuccess) {
        if (statusTimeout) {
            clearTimeout(statusTimeout);
        }
        
        element.textContent = message;
        element.style.display = 'block';
        element.className = 'status ' + (isSuccess ? 'success' : 'error');

        statusTimeout = setTimeout(() => { 
            element.style.display = 'none'; 
        }, 3000);
    }

    function handleLogout() {
        window.location.href = '/logout';
    }

         async function viewCodebeamerItem(type) {
         let itemId;
         let statusElement;
         
         if (type === 'vectorcastMultiple') {
             const itemSelector = document.getElementById('multipleItemSelector');
             itemId = itemSelector.value;
             statusElement = document.getElementById('multipleVectorcastStatus');
         } else {
             const itemElement = document.getElementById(`${type}ItemId`);
             itemId = itemElement ? itemElement.value : '';
             statusElement = document.getElementById(`${type}Status`);
         }
         
         if (!itemId) {
             showStatus(statusElement, 'ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”', false);
             return;
         }

         const serverUrl = '<%= serverUrl %>';
         if (!serverUrl) {
             showStatus(statusElement, 'Codebeamer ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', false);
             return;
         }

         try {
             showStatus(statusElement, 'CodeBeamer ì—°ê²° ì¤‘...', true);
             
             // Use auto-login redirect page approach
             const currentHost = window.location.origin;
             const autoLoginUrl = `${currentHost}/codebeamer-access?item=${itemId}`;
             showStatus(statusElement, 'CodeBeamer ìë™ ë¡œê·¸ì¸ ì¤‘... (vectorCAST ê¶Œí•œìœ¼ë¡œ)', true);
             window.open(autoLoginUrl, '_blank');
             
         } catch (error) {
             console.error('CodeBeamer access error:', error);
             showStatus(statusElement, 'CodeBeamer ì—°ê²° ì‹¤íŒ¨, ê¸°ë³¸ ë°©ì‹ìœ¼ë¡œ ì—°ê²° ì¤‘...', false);
             
             // Fallback to normal URL if everything fails
             const itemUrl = `${serverUrl}/item/${itemId}`;
             window.open(itemUrl, '_blank');
         }
     }

    function initDragAndDrop(type) {
        const dropZone = document.getElementById(`${type}DropZone`);
        const fileInput = document.getElementById(`${type}FileInput`);
        
        if (!dropZone || !fileInput) {
            console.log(`Drop zone or file input for ${type} not found.`);
            return;
        }

        restoreExistingFile(type);

        dropZone.addEventListener('click', (e) => {
            if (e.target === dropZone || e.target.classList.contains('custom-file-button')) {
                fileInput.click();
            }
        });

        fileInput.addEventListener('change', (event) => {
            handleFiles(type, event.target.files);
            event.target.value = '';
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.add('drag-over');
            }, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.remove('drag-over');
            }, false);
        });
 
        dropZone.addEventListener('drop', (event) => {
            const dt = event.dataTransfer;
            const files = dt.files;
            handleFiles(type, files);
        }, false);
    }

    function restoreExistingFile(type) {
        const existingFileName = localStorage.getItem(`${type}DroppedFile`);
        if (existingFileName) {
            const fileInfo = document.getElementById(`${type}FileInfo`);
            const fileName = document.getElementById(`${type}FileName`);
            const dropZone = document.getElementById(`${type}DropZone`);
            
            if (fileInfo && fileName && dropZone) {
                fileName.textContent = existingFileName;
                fileInfo.style.display = 'flex';
                dropZone.style.display = 'flex'; 
            }
        }
    }
    
    function preventDefaults(event) {
        event.preventDefault();
        event.stopPropagation();
    }

    function handleFiles(type, files) {
        if (!files.length) return;
        
        const file = files[0];
        const statusElement = document.getElementById(`${type}Status`);
 
        if (!file.name.toLowerCase().endsWith('.html')) {
            showStatus(statusElement, 'HTML íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤', false);
            return;
        }

        const existingFileName = localStorage.getItem(`${type}DroppedFile`);
        if (existingFileName) {
            deleteReportContent(existingFileName).catch(err => {
                console.error('Error deleting existing file content:', err);
            });
        }

        localStorage.setItem(`${type}DroppedFile`, file.name);

        const fileInfo = document.getElementById(`${type}FileInfo`);
        const fileName = document.getElementById(`${type}FileName`);
        const dropZone = document.getElementById(`${type}DropZone`);
        
        fileName.textContent = file.name;
        fileInfo.style.display = 'flex';

        dropZone.style.display = 'flex';

        const reader = new FileReader();
        reader.onload = (event) => {
            const fileContent = event.target.result;
            storeReportContent(file.name, fileContent).then(() => {
                showStatus(statusElement, 'íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤', true);
            }).catch(error => {
                console.error('Error storing file content:', error);
                showStatus(statusElement, 'íŒŒì¼ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', false);
            });
        };
        reader.onerror = () => {
            showStatus(statusElement, 'íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', false);
        };
        reader.readAsText(file);
    }

    function removeDroppedFile(type) {
        const fileInfo = document.getElementById(`${type}FileInfo`);
        const dropZone = document.getElementById(`${type}DropZone`);
        const fileInput = document.getElementById(`${type}FileInput`);
        const fileName = localStorage.getItem(`${type}DroppedFile`);
        
        fileInfo.style.display = 'none';
        dropZone.style.display = 'flex';
        fileInput.value = '';

        if (fileName) {
            deleteReportContent(fileName).catch(err => {
                console.error('Error deleting file content:', err);
            });
        }
        
        localStorage.removeItem(`${type}DroppedFile`);
    }

    function initMultipleFileUpload() {
        const dropZone = document.getElementById('multipleVectorcastDropZone');
        const fileInput = document.getElementById('multipleVectorcastFileInput');
        const folderInput = document.getElementById('multipleVectorcastFolderInput');
        
        if (!dropZone || !fileInput || !folderInput) return;

        fileInput.addEventListener('change', (event) => {
            handleMultipleFiles(event.target.files);
        });

        folderInput.addEventListener('change', (event) => {
            handleMultipleFiles(event.target.files);
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.add('drag-over');
            }, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.remove('drag-over');
            }, false);
        });

        dropZone.addEventListener('drop', (event) => {
            const dt = event.dataTransfer;
            const files = dt.files;

            handleMultipleFiles(files);
        }, false);

        loadSavedMultipleFiles();
    }

    function loadSavedMultipleFiles() {
        const filesList = JSON.parse(sessionStorage.getItem('vectorcastMultipleFiles') || '[]');
        if (filesList.length > 0) {
            updateMultipleFilesUI(filesList);
        }
    }

    function handleMultipleFiles(files) {
        if (!files.length) return;
        
        const statusElement = document.getElementById('multipleVectorcastStatus');
        const existingFiles = JSON.parse(sessionStorage.getItem('vectorcastMultipleFiles') || '[]');
        const htmlFiles = Array.from(files).filter(file => file.name.toLowerCase().endsWith('.html'));
        
        if (htmlFiles.length === 0) {
            showStatus(statusElement, 'HTML íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤', false);
            return;
        }

        const newFiles = htmlFiles.filter(file => !existingFiles.some(existing => existing.name === file.name));
        
        if (newFiles.length === 0) {
            showStatus(statusElement, 'ëª¨ë“  íŒŒì¼ì´ ì´ë¯¸ ì—…ë¡œë“œë˜ì–´ ìˆìŠµë‹ˆë‹¤', false);
            return;
        }

        showStatus(statusElement, `${newFiles.length}ê°œ íŒŒì¼ì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘...`, true);

        let processedCount = 0;
        let successCount = 0;
        const updatedFiles = [...existingFiles];

        newFiles.forEach((file, index) => {
            const reader = new FileReader();
            
            reader.onload = (event) => {
                try {
                    const fileData = {
                        name: file.name,
                        size: file.size,
                        content: event.target.result
                    };

                    storeReportContent(file.name, fileData.content)
                        .then(() => {
                            updatedFiles.push({ name: file.name, size: file.size });
                            successCount++;
                            processedCount++;
                            
                            sessionStorage.setItem('vectorcastMultipleFiles', JSON.stringify(updatedFiles));
                            updateMultipleFilesUI(updatedFiles);
           
                            if (processedCount === newFiles.length) {
                                showStatus(statusElement, `${successCount}ê°œ íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤`, true);
    
                                document.getElementById('multipleVectorcastFileInput').value = '';
                                document.getElementById('multipleVectorcastFolderInput').value = '';
                            }
                        })
                        .catch(error => {
                            console.error('Error storing file content:', error);
                            processedCount++;
                            
                            if (processedCount === newFiles.length) {
                                showStatus(statusElement, `${successCount}ê°œ íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ (${newFiles.length - successCount}ê°œ ì‹¤íŒ¨)`, successCount > 0);
                            }
                        });
                } catch (error) {
                    console.error('Error processing file:', error);
                    processedCount++;
                    
                    if (processedCount === newFiles.length) {
                        showStatus(statusElement, `${successCount}ê°œ íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ (${newFiles.length - successCount}ê°œ ì‹¤íŒ¨)`, successCount > 0);
                    }
                }
            };
            
            reader.onerror = () => {
                processedCount++;
                if (processedCount === newFiles.length) {
                    showStatus(statusElement, `${successCount}ê°œ íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ (${newFiles.length - successCount}ê°œ ì‹¤íŒ¨)`, successCount > 0);
                }
            };
            
            reader.readAsText(file);
        });
    }

    const DB_NAME = 'VectorcastDB';
    const STORE_NAME = 'reportContents';
    const DB_VERSION = 1;

    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            
            request.onerror = event => {
                reject('Error opening database: ' + event.target.error);
            };
            
            request.onsuccess = event => {
                resolve(event.target.result);
            };
            
            request.onupgradeneeded = event => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME, { keyPath: 'fileName' });
                }
            };
        });
    }

    function storeReportContent(fileName, content) {
        return openDB().then(db => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                const request = store.put({ fileName, content });
                
                request.onerror = event => {
                    reject('Error storing report content: ' + event.target.error);
                };
                
                request.onsuccess = event => {
                    resolve();
                };
            });
        });
    }

    function getReportContent(fileName) {
        return openDB().then(db => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                
                const request = store.get(fileName);
                
                request.onerror = event => {
                    reject('Error getting report content: ' + event.target.error);
                };
                
                request.onsuccess = event => {
                    resolve(request.result ? request.result.content : null);
                };
            });
        });
    }

    function deleteReportContent(fileName) {
        return openDB().then(db => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                const request = store.delete(fileName);
                
                request.onerror = event => {
                    reject('Error deleting report content: ' + event.target.error);
                };
                
                request.onsuccess = event => {
                    resolve();
                };
            });
        });
    }

    function clearAllReportContents() {
        return openDB().then(db => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                const request = store.clear();
                
                request.onerror = event => {
                    reject('Error clearing report contents: ' + event.target.error);
                };
                
                request.onsuccess = event => {
                    resolve();
                };
            });
        });
    }

    function updateMultipleFilesUI(files) {
        const filesContainer = document.getElementById('multipleVectorcastFilesInfo');
        const filesList = document.getElementById('multipleVectorcastFilesList');
        const filesCount = document.getElementById('multipleVectorcastFilesCount');
        const dropZone = document.getElementById('multipleVectorcastDropZone');

        filesCount.textContent = files.length;
        filesList.innerHTML = '';
        files.forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'multiple-file-item';
            
            const fileSize = formatFileSize(file.size);
            fileItem.innerHTML = `
                <span>${index + 1}. ${file.name} (${fileSize})</span>
                <button class="remove-file-btn-small" data-index="${index}">Ã—</button>
            `;
            
            filesList.appendChild(fileItem);

            const removeBtn = fileItem.querySelector('.remove-file-btn-small');
            removeBtn.addEventListener('click', () => {
                removeMultipleFile(index);
            });
        });

        if (files.length > 0) {
            filesContainer.style.display = 'block';
        } else {
            filesContainer.style.display = 'none';
        }
        dropZone.style.display = 'flex';
    }

    function removeMultipleFile(index) {
        const files = JSON.parse(sessionStorage.getItem('vectorcastMultipleFiles') || '[]');
        
        if (index >= 0 && index < files.length) {
            const removedFile = files.splice(index, 1)[0];
            deleteReportContent(removedFile.name).catch(err => {
                console.error('Error deleting content:', err);
            });

            sessionStorage.setItem('vectorcastMultipleFiles', JSON.stringify(files));
            updateMultipleFilesUI(files);

            const statusElement = document.getElementById('multipleVectorcastStatus');
            showStatus(statusElement, `${removedFile.name} íŒŒì¼ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤`, true);
        }
    }

    function removeAllDroppedFiles() {
        sessionStorage.removeItem('vectorcastMultipleFiles');
        clearAllReportContents().catch(err => {
            console.error('Error clearing contents:', err);
        });

        updateMultipleFilesUI([]);

        const statusElement = document.getElementById('multipleVectorcastStatus');
        showStatus(statusElement, 'ëª¨ë“  íŒŒì¼ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤', true);
    }

    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function updateMultipleReports() {
        const username = '<%= username %>';
        const itemSelector = document.getElementById('multipleItemSelector');
        const itemId = itemSelector.value;
        const statusElement = document.getElementById('multipleVectorcastStatus');
        const progressBar = document.getElementById('multipleVectorcastProgress');
        const progressFill = progressBar.querySelector('.progress-fill');
        const progressText = progressBar.querySelector('.progress-text');
        const summaryElement = document.getElementById('multipleReportsSummary');
        
        if (!itemId) {
            showStatus(statusElement, 'ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”', false);
            return;
        }
        
        const files = JSON.parse(sessionStorage.getItem('vectorcastMultipleFiles') || '[]');
        
        if (files.length === 0) {
            showStatus(statusElement, 'ë¦¬í¬íŠ¸ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”', false);
            return;
        }

        progressBar.style.display = 'block';
        progressFill.style.width = '5%';
        progressText.textContent = '5%';
    
        statusElement.textContent = 'ë¦¬í¬íŠ¸ ì²˜ë¦¬ ì¤‘...';
        statusElement.style.display = 'block';
        statusElement.className = 'status';
   


        const contentPromises = files.map(file => getReportContent(file.name));
        
        Promise.all(contentPromises)
            .then(reportContents => {
                const validReports = reportContents.filter(content => content !== null);
                
                if (validReports.length === 0) {
                    throw new Error('ë¦¬í¬íŠ¸ ë‚´ìš©ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }
                
                progressFill.style.width = '25%';
                progressText.textContent = '25%';

                return fetch(`/api/vectorcast/multipleReports`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({ reports: validReports }),
                    credentials: 'include'
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(data => {
                            throw new Error(data.error || 'ë¦¬í¬íŠ¸ ì²˜ë¦¬ ì‹¤íŒ¨');
                        });
                    }
                    
                    progressFill.style.width = '50%';
                    progressText.textContent = '50%';
                    
                    return response.json().then(data => {
                        updateMultipleReportSummary(data);
                        summaryElement.style.display = 'block';
                        
                        // Auto-hide summary after 10 seconds
                        setTimeout(() => {
                            summaryElement.style.display = 'none';
                        }, 10000);

                        console.log(`Sending ${validReports.length} reports to CodeBeamer API`);
                        return fetch(`/api/codebeamer/items/${itemId}/fields?type=vectorcast-multiple`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify({  reports: validReports, processedData: data }),
                            credentials: 'include'
                        });
                    });
                });
            })
            .then(response => {
                progressFill.style.width = '75%';
                progressText.textContent = '75%';
                
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || 'Codebeamer ì—…ë°ì´íŠ¸ ì‹¤íŒ¨');
                    });
                }
                
                return response.json();
            })
            .then(data => {
                progressFill.style.width = '100%';
                progressText.textContent = '100%';
                
                showStatus(statusElement, 'Codebeamer ì—…ë°ì´íŠ¸ ì™„ë£Œ', true);
                setTimeout(() => {
                    progressBar.style.display = 'none';
                }, 2000);
            })
            .catch(error => {
                progressBar.style.display = 'none';
                showStatus(statusElement, error.message, false);
                console.error('Error:', error);
            });
    }

    function updateMultipleReportSummary(data) {
        function hasValidCoverage(coverage) {
            if (!coverage || coverage === "ì•Œìˆ˜ì—†ìŒ") {
                return false;
            }

            if (coverage.match(/^0\s*\/\s*0\s*\(\s*0%\s*\)$/) || coverage === "0%") {
                return false;
            }
            
            return true;
        }

        function getCoverageClass(value) {
            const percentage = parseInt(value || 0);
            if (percentage >= 99) {
                return 'summary-value good';
            } else if (percentage >= 70) {
                return 'summary-value warning';
            } else {
                return 'summary-value bad';
            }
        }

        document.getElementById('multipleReportsTotalFiles').textContent = data.reportCount || 0;
        document.getElementById('multipleReportsTestCases').textContent = data.passFail || '0 / 0 PASS';
        
        const passRateElement = document.getElementById('multipleReportsPassRate');
        const passRate = data.passFailRate || 0;
        passRateElement.textContent = `${passRate}%`;
        passRateElement.className = getCoverageClass(passRate);

        const summaryGrid = document.getElementById('multipleReportsSummaryGrid');

        const existingCoverageItems = summaryGrid.querySelectorAll('.coverage-summary-item');
        existingCoverageItems.forEach(item => item.remove());

        const coverageTypes = [
            {
                key: 'statementCoverage',
                percentageKey: 'statementPercentage',
                label: 'Statement Coverage'
            },
            {
                key: 'branchCoverage',
                percentageKey: 'branchPercentage',
                label: 'Branch Coverage'
            },
            {
                key: 'functionCoverage',
                percentageKey: 'functionPercentage',
                label: 'Function Coverage'
            },
            {
                key: 'functionCallCoverage',
                percentageKey: 'functionCallPercentage',
                label: 'Function Call Coverage'
            }
        ];

        coverageTypes.forEach(coverage => {
            if (hasValidCoverage(data[coverage.key])) {
                const coverageItem = document.createElement('div');
                coverageItem.className = 'summary-item coverage-summary-item';
                
                const label = document.createElement('span');
                label.className = 'summary-label';
                label.textContent = coverage.label;
                
                const value = document.createElement('span');
                value.className = getCoverageClass(data[coverage.percentageKey]);
                value.textContent = data[coverage.key] || '0%';
                
                coverageItem.appendChild(label);
                coverageItem.appendChild(value);
                summaryGrid.appendChild(coverageItem);
            }
        });
    }

    let actionCounter = 1;

    function addVectorcastAction() {
        const actionsContainer = document.getElementById('vectorcastActions');
        const newAction = document.createElement('div');
        newAction.className = 'vectorcast-action';
        newAction.setAttribute('data-index', actionCounter);
        
        newAction.innerHTML = `
            <div class="action-inputs">
                <div class="selector-container">
                    <select class="action-project-selector" data-index="${actionCounter}" onchange="loadTrackers(${actionCounter})">
                        <option value="">í”„ë¡œì íŠ¸ ì„ íƒ</option>
                    </select>
                    <select class="action-tracker-selector" data-index="${actionCounter}" onchange="loadItems(${actionCounter})" disabled>
                        <option value="">íŠ¸ë˜ì»¤ ì„ íƒ</option>
                    </select>
                    <select class="action-item-selector" data-index="${actionCounter}" disabled>
                        <option value="">ì•„ì´í…œ ì„ íƒ</option>
                    </select>
                </div>
                <div class="action-file-drop-zone" data-index="${actionCounter}">
                    <button class="file-select-btn" onclick="selectFileForAction(${actionCounter})">íŒŒì¼ ì„ íƒ</button>
                    <input type="file" class="action-file-input" accept=".html" style="display: none;" onchange="handleActionFileChange(${actionCounter})">
                    <span class="action-file-name">íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</span>
                    <button class="clear-file-btn" onclick="clearActionFile(${actionCounter})" style="display: none;" title="íŒŒì¼ ì œê±°">ğŸ—‘ï¸</button>
                </div>
                <button class="action-view-codebeamer" onclick="viewActionCodebeamer(${actionCounter})">ì½”ë“œë¹„ë¨¸ ë³´ê¸°</button>
                <button class="action-view-report" onclick="viewActionReport(${actionCounter})">ë¦¬í¬íŠ¸ ë³´ê¸°</button>
                <button class="remove-action-btn" onclick="removeVectorcastAction(${actionCounter})">Ã—</button>
            </div>
        `;
        
        actionsContainer.appendChild(newAction);
        updateRemoveButtonVisibility();
        initActionDragAndDrop(actionCounter);
        loadProjectsForAction(actionCounter);
        actionCounter++;
    }

         async function viewActionCodebeamer(index) {
         const action = document.querySelector(`.vectorcast-action[data-index="${index}"]`);
         const itemSelector = action.querySelector('.action-item-selector');
         const itemId = itemSelector.value.trim();
         const statusElement = document.getElementById('vectorcastStatus');
         
         if (!itemId) {
             showStatus(statusElement, 'ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”', false);
             return;
         }

         const serverUrl = '<%= serverUrl %>';
         if (!serverUrl) {
             showStatus(statusElement, 'Codebeamer ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', false);
             return;
         }

         try {
             showStatus(statusElement, 'CodeBeamer ì—°ê²° ì¤‘...', true);
             
             // Use auto-login redirect page approach
             const currentHost = window.location.origin;
             const autoLoginUrl = `${currentHost}/codebeamer-access?item=${itemId}`;
             showStatus(statusElement, 'CodeBeamer ìë™ ë¡œê·¸ì¸ ì¤‘... (vectorCAST ê¶Œí•œìœ¼ë¡œ)', true);
             window.open(autoLoginUrl, '_blank');
             
         } catch (error) {
             console.error('CodeBeamer access error:', error);
             showStatus(statusElement, 'CodeBeamer ì—°ê²° ì‹¤íŒ¨, ê¸°ë³¸ ë°©ì‹ìœ¼ë¡œ ì—°ê²° ì¤‘...', false);
             
             // Fallback to normal URL if everything fails
             const itemUrl = `${serverUrl}/item/${itemId}`;
             window.open(itemUrl, '_blank');
         }
     }

    function viewActionReport(index) {
        const action = document.querySelector(`.vectorcast-action[data-index="${index}"]`);
        const statusElement = document.getElementById('vectorcastStatus');
        const savedData = sessionStorage.getItem(`vectorcastAction_${index}`);
        
        if (savedData) {
            try {
                const fileData = JSON.parse(savedData);
                const blob = new Blob([fileData.content], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                window.open(url, '_blank');
                return;
            } catch (error) {
                console.error('Error reading saved file data:', error);
            }
        }

        const fileInput = action.querySelector('.action-file-input');
        if (!fileInput.files.length) {
            showStatus(statusElement, 'ë¦¬í¬íŠ¸ íŒŒì¼ì„ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”', false);
            return;
        }

        const file = fileInput.files[0];
        const reader = new FileReader();
        reader.onload = function(e) {
            const reportContent = e.target.result;
            const blob = new Blob([reportContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank');
        };
        reader.onerror = function() {
            showStatus(statusElement, 'ë¦¬í¬íŠ¸ë¥¼ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', false);
        };
        reader.readAsText(file);
    }

    function removeVectorcastAction(index) {
        const action = document.querySelector(`.vectorcast-action[data-index="${index}"]`);
        if (action) {
            sessionStorage.removeItem(`vectorcastAction_${index}`);
            action.remove();
            updateRemoveButtonVisibility();
        }
    }

    function updateRemoveButtonVisibility() {
        const actions = document.querySelectorAll('.vectorcast-action');
        actions.forEach((action, index) => {
            const removeBtn = action.querySelector('.remove-action-btn');
            if (removeBtn) {
                removeBtn.style.display = actions.length > 1 ? 'flex' : 'none';
            }
        });
    }

    function selectFileForAction(index) {
        const action = document.querySelector(`.vectorcast-action[data-index="${index}"]`);
        const fileInput = action.querySelector('.action-file-input');
        fileInput.click();
    }

    function handleActionFileChange(index) {
        const action = document.querySelector(`.vectorcast-action[data-index="${index}"]`);
        const fileInput = action.querySelector('.action-file-input');
        const fileName = action.querySelector('.action-file-name');
        const clearBtn = action.querySelector('.clear-file-btn');
        
        if (fileInput.files.length > 0) {
            const file = fileInput.files[0];
            fileName.textContent = file.name;
            fileName.title = file.name; 
            fileName.classList.add('has-file');
            clearBtn.style.display = 'inline-block';

            const reader = new FileReader();
            reader.onload = (event) => {
                const fileData = {
                    name: file.name,
                    size: file.size,
                    content: event.target.result
                };
                sessionStorage.setItem(`vectorcastAction_${index}`, JSON.stringify(fileData));
            };
            reader.readAsText(file);
        } else {
            fileName.textContent = 'íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤';
            fileName.title = ''; 
            fileName.classList.remove('has-file');
            clearBtn.style.display = 'none';
            sessionStorage.removeItem(`vectorcastAction_${index}`);
        }
    }

    function clearActionFile(index) {
        const action = document.querySelector(`.vectorcast-action[data-index="${index}"]`);
        const fileInput = action.querySelector('.action-file-input');
        const fileName = action.querySelector('.action-file-name');
        const clearBtn = action.querySelector('.clear-file-btn');
        
        // Clear the file input
        fileInput.value = '';
        
        // Reset the display
        fileName.textContent = 'íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤';
        fileName.title = '';
        fileName.classList.remove('has-file');
        clearBtn.style.display = 'none';
        
        // Remove from session storage
        sessionStorage.removeItem(`vectorcastAction_${index}`);
        
        // Show success message
        const statusElement = document.getElementById('vectorcastStatus');
        showStatus(statusElement, 'íŒŒì¼ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤', true);
    }

    async function processMultipleVectorcastActions() {
        const actions = document.querySelectorAll('.vectorcast-action');
        const statusElement = document.getElementById('vectorcastStatus');
        const progressBar = document.getElementById('vectorcastProgress');
        const progressFill = progressBar.querySelector('.progress-fill');
        const progressText = progressBar.querySelector('.progress-text');
        const resultsDiv = document.getElementById('vectorcastResults');
        const resultsList = document.getElementById('vectorcastResultsList');

        progressBar.style.display = 'none';
        resultsDiv.style.display = 'none';

        const reports = [];

        for (let i = 0; i < actions.length; i++) {
            const action = actions[i];
            const itemSelector = action.querySelector('.action-item-selector');
            const itemId = itemSelector.value.trim();
            const fileInput = action.querySelector('.action-file-input');
            
            if (!itemId) {
                showStatus(statusElement, 'ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”', false);
                return;
            }

            const actionIndex = action.getAttribute('data-index');
            const savedData = sessionStorage.getItem(`vectorcastAction_${actionIndex}`);
            
            if (!savedData && !fileInput.files.length) {
                showStatus(statusElement, 'ë¦¬í¬íŠ¸ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”', false);
                return;
            }

            try {
                let fileContent;
                let fileName;
                
                if (savedData) {
                    const fileData = JSON.parse(savedData);
                    fileContent = fileData.content;
                    fileName = fileData.name;
                } else {
                    fileContent = await readFileContent(fileInput.files[0]);
                    fileName = fileInput.files[0].name;
                }
                
                reports.push({
                    itemId: itemId,
                    reportContent: fileContent,
                    fileName: fileName
                });
            } catch (error) {
                showStatus(statusElement, `íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ - ${error.message}`, false);
                return;
            }
        }

        if (reports.length === 0) {
            showStatus(statusElement, 'ì‹¤í–‰í•  ì•¡ì…˜ì´ ì—†ìŠµë‹ˆë‹¤', false);
            return;
        }

        progressBar.style.display = 'block';
        progressFill.style.width = '0%';
        progressText.textContent = '0%';
        resultsDiv.style.display = 'none';

        try {
            showStatus(statusElement, `${reports.length}ê°œ ì „ì†¡ ì¤‘...`, true);

            console.log('Reports being sent:', reports.map(r => ({
                itemId: r.itemId,
                fileName: r.fileName,
                contentLength: r.reportContent ? r.reportContent.length : 0
            })));

            const response = await fetch('/api/codebeamer/bulk-single-reports', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({ reports }),
                credentials: 'include'
            });

            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.error || 'ì—…ë¡œë“œ ì‹¤íŒ¨');
            }

            const attachmentInfo = result.attachmentSuccessCount > 0 ? `, ì²¨ë¶€íŒŒì¼ ${result.attachmentSuccessCount}ê°œ` : '';
            showStatus(statusElement, `ì™„ë£Œ: ${result.successCount}ê°œ ì„±ê³µ, ${result.failureCount}ê°œ ì‹¤íŒ¨${attachmentInfo}`, result.failureCount === 0);

            const username = '<%= username %>';
            
            if (result.results && result.results.length > 0) {
                resultsList.innerHTML = result.results.map(r => {
                    let statusIcon = '';
                    let attachmentStatus = '';
                    
                    if (r.fieldUpdateSuccess && r.attachmentSuccess) {
                        statusIcon = 'âœ…ğŸ“';
                    } else if (r.fieldUpdateSuccess && !r.attachmentSuccess) {
                        statusIcon = 'âœ…âŒ';
                        attachmentStatus = ' (ì²¨ë¶€íŒŒì¼ ì‹¤íŒ¨)';
                    } else if (r.fieldUpdateSuccess) {
                        statusIcon = 'âœ…';
                    } else {
                        statusIcon = 'âŒ';
                    }
                    
                    return `
                        <div class="result-item ${r.success ? 'success' : 'error'}">
                            <strong>${statusIcon} Item ${r.itemId}</strong>: ${r.success ? r.message : r.error}${attachmentStatus}
                        </div>
                    `;
                }).join('');
                resultsDiv.style.display = 'block';
                
                // Auto-hide results after 5 seconds
                setTimeout(() => {
                    resultsDiv.style.display = 'none';
                }, 5000);
            }

            progressFill.style.width = '100%';
            progressText.textContent = '100%';

            setTimeout(() => {
                progressBar.style.display = 'none';
            }, 2000);

        } catch (error) {
            progressBar.style.display = 'none';
            showStatus(statusElement, error.message, false);
            console.error('Multiple VectorCAST actions error:', error);
        }
    }

    function readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(new Error('íŒŒì¼ ì½ê¸° ì‹¤íŒ¨'));
            reader.readAsText(file);
        });
    }

    function initActionDragAndDrop(index) {
        const dropZone = document.querySelector(`.action-file-drop-zone[data-index="${index}"]`);
        const fileInput = dropZone.querySelector('.action-file-input');
        
        if (!dropZone || !fileInput) return;

        dropZone.addEventListener('click', (e) => {
            if (e.target === dropZone || e.target.classList.contains('action-file-name')) {
                fileInput.click();
            }
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.add('drag-over');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.remove('drag-over');
            }, false);
        });

        dropZone.addEventListener('drop', (event) => {
            const dt = event.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                const file = files[0];
                if (file.name.toLowerCase().endsWith('.html')) {
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    fileInput.files = dataTransfer.files;
  
                    handleActionFileChange(index);
                } else {
                    const statusElement = document.getElementById('vectorcastStatus');
                    showStatus(statusElement, 'HTML íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤', false);
                }
            }
        }, false);
    }

    function preventDefaults(event) {
        event.preventDefault();
        event.stopPropagation();
    }

    function initAllActionDragAndDrop() {
        const actions = document.querySelectorAll('.vectorcast-action');
        actions.forEach(action => {
            const index = action.getAttribute('data-index');
            initActionDragAndDrop(index);
        });
    }

    function restoreSavedFiles() {
        const actions = document.querySelectorAll('.vectorcast-action');
        actions.forEach(action => {
            const index = action.getAttribute('data-index');
            const savedData = sessionStorage.getItem(`vectorcastAction_${index}`);
            
            if (savedData) {
                try {
                    const fileData = JSON.parse(savedData);
                    const fileName = action.querySelector('.action-file-name');
                    
                    if (fileName) {
                        fileName.textContent = fileData.name;
                        fileName.title = fileData.name; 
                        fileName.classList.add('has-file');
                    }
                } catch (error) {
                    console.error('Error restoring saved file:', error);
                    sessionStorage.removeItem(`vectorcastAction_${index}`);
                }
            }
        });
    }

    let cachedProjects = null;

    document.addEventListener('DOMContentLoaded', () => {
        updateRemoveButtonVisibility();
        initAllActionDragAndDrop();
        restoreSavedFiles();
        loadAllProjects();
    });

    async function fetchProjects() {
        if (cachedProjects) {
            return cachedProjects;
        }

        try {
            const response = await fetch('/api/codebeamer/projects', {
                method: 'GET',
                credentials: 'include'
            });
            
            if (!response.ok) {
                throw new Error('Failed to fetch projects');
            }
            
            cachedProjects = await response.json();
            return cachedProjects;
        } catch (error) {
            console.error('Error loading projects:', error);
            throw error;
        }
    }

    async function loadAllProjects() {
        try {
            const projects = await fetchProjects();
            loadProjectsForAction(0, projects);
            loadProjectsForMultiple(projects);
        } catch (error) {
            console.error('Error loading projects:', error);
        }
    }

    function loadProjectsForAction(index, projects) {
        const projectSelector = document.querySelector(`.action-project-selector[data-index="${index}"]`);
        
        if (projectSelector) {
            projectSelector.innerHTML = '<option value="">í”„ë¡œì íŠ¸ ì„ íƒ</option>';
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                option.textContent = project.name;
                projectSelector.appendChild(option);
            });
        }
    }

    function loadProjectsForMultiple(projects) {
        const projectSelector = document.getElementById('multipleProjectSelector');
        
        if (projectSelector) {
            projectSelector.innerHTML = '<option value="">í”„ë¡œì íŠ¸ ì„ íƒ</option>';
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                option.textContent = project.name;
                projectSelector.appendChild(option);
            });
        }
    }

    async function loadTrackers(index) {
        const projectSelector = document.querySelector(`.action-project-selector[data-index="${index}"]`);
        const trackerSelector = document.querySelector(`.action-tracker-selector[data-index="${index}"]`);
        const itemSelector = document.querySelector(`.action-item-selector[data-index="${index}"]`);
        
        trackerSelector.innerHTML = '<option value="">íŠ¸ë˜ì»¤ ì„ íƒ</option>';
        itemSelector.innerHTML = '<option value="">ì•„ì´í…œ ì„ íƒ</option>';
        trackerSelector.disabled = true;
        itemSelector.disabled = true;
        
        if (!projectSelector.value) return;
        
        try {
            const response = await fetch(`/api/codebeamer/projects/${projectSelector.value}/trackers`, {
                method: 'GET',
                credentials: 'include'
            });
            
            if (!response.ok) {
                throw new Error('Failed to fetch trackers');
            }
            
            const trackers = await response.json();
            trackers.forEach(tracker => {
                const option = document.createElement('option');
                option.value = tracker.id;
                option.textContent = tracker.name;
                trackerSelector.appendChild(option);
            });
            
            trackerSelector.disabled = false;
        } catch (error) {
            console.error('Error loading trackers:', error);
        }
    }

    async function loadMultipleTrackers() {
        const projectSelector = document.getElementById('multipleProjectSelector');
        const trackerSelector = document.getElementById('multipleTrackerSelector');
        const itemSelector = document.getElementById('multipleItemSelector');
        
        trackerSelector.innerHTML = '<option value="">íŠ¸ë˜ì»¤ ì„ íƒ</option>';
        itemSelector.innerHTML = '<option value="">ì•„ì´í…œ ì„ íƒ</option>';
        trackerSelector.disabled = true;
        itemSelector.disabled = true;
        
        if (!projectSelector.value) return;
        
        try {
            const response = await fetch(`/api/codebeamer/projects/${projectSelector.value}/trackers`, {
                method: 'GET',
                credentials: 'include'
            });
            
            if (!response.ok) {
                throw new Error('Failed to fetch trackers');
            }
            
            const trackers = await response.json();
            trackers.forEach(tracker => {
                const option = document.createElement('option');
                option.value = tracker.id;
                option.textContent = tracker.name;
                trackerSelector.appendChild(option);
            });
            
            trackerSelector.disabled = false;
        } catch (error) {
            console.error('Error loading trackers:', error);
        }
    }

    async function loadItems(index) {
        const trackerSelector = document.querySelector(`.action-tracker-selector[data-index="${index}"]`);
        const itemSelector = document.querySelector(`.action-item-selector[data-index="${index}"]`);
        
        console.log('loadItems called for index:', index, 'tracker value:', trackerSelector?.value);
        
        itemSelector.innerHTML = '<option value="">ì•„ì´í…œ ì„ íƒ</option>';
        itemSelector.disabled = true;
        
        if (!trackerSelector.value) {
            console.log('No tracker selected, returning');
            return;
        }
        
        try {
            const apiUrl = `/api/codebeamer/trackers/${trackerSelector.value}/items`;
            console.log('Fetching items from:', apiUrl);
            
            const response = await fetch(apiUrl, {
                method: 'GET',
                credentials: 'include'
            });
            
            console.log('Response status:', response.status);
            console.log('Response ok:', response.ok);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('API error response:', errorText);
                throw new Error(`Failed to fetch items: ${response.status} ${errorText}`);
            }
            
            const responseData = await response.json();
            console.log('Raw response data:', responseData);
            
            // Handle different response structures
            let items;
            if (Array.isArray(responseData)) {
                items = responseData;
            } else if (responseData.itemRefs && Array.isArray(responseData.itemRefs)) {
                items = responseData.itemRefs;
            } else if (responseData.items && Array.isArray(responseData.items)) {
                items = responseData.items;
            } else if (responseData.data && Array.isArray(responseData.data)) {
                items = responseData.data;
            } else {
                console.error('Unexpected response structure:', responseData);
                throw new Error('Invalid response format');
            }
            
            console.log('Items array:', items.length, items);
            
            items.forEach(item => {
                const option = document.createElement('option');
                option.value = item.id;
                
                // Truncate long item names for display
                let displayName = `${item.id} - ${item.name}`;
                if (displayName.length > 50) {
                    displayName = displayName.substring(0, 47) + '...';
                }
                option.textContent = displayName;
                option.title = `${item.id} - ${item.name}`; // Full name in tooltip
                itemSelector.appendChild(option);
            });
            
            itemSelector.disabled = false;
            console.log('Items loaded successfully, selector enabled');
        } catch (error) {
            console.error('Error loading items:', error);
        }
    }

    async function loadMultipleItems() {
        const trackerSelector = document.getElementById('multipleTrackerSelector');
        const itemSelector = document.getElementById('multipleItemSelector');
        
        console.log('loadMultipleItems called, tracker value:', trackerSelector.value);
        
        itemSelector.innerHTML = '<option value="">ì•„ì´í…œ ì„ íƒ</option>';
        itemSelector.disabled = true;
        
        if (!trackerSelector.value) {
            console.log('No tracker selected, returning');
            return;
        }
        
        try {
            const apiUrl = `/api/codebeamer/trackers/${trackerSelector.value}/items`;
            console.log('Fetching items from:', apiUrl);
            
            const response = await fetch(apiUrl, {
                method: 'GET',
                credentials: 'include'
            });
            
            console.log('Response status:', response.status);
            console.log('Response ok:', response.ok);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('API error response:', errorText);
                throw new Error(`Failed to fetch items: ${response.status} ${errorText}`);
            }
            
            const responseData = await response.json();
            console.log('Raw response data:', responseData);
            
            // Handle different response structures
            let items;
            if (Array.isArray(responseData)) {
                items = responseData;
            } else if (responseData.itemRefs && Array.isArray(responseData.itemRefs)) {
                items = responseData.itemRefs;
            } else if (responseData.items && Array.isArray(responseData.items)) {
                items = responseData.items;
            } else if (responseData.data && Array.isArray(responseData.data)) {
                items = responseData.data;
            } else {
                console.error('Unexpected response structure:', responseData);
                throw new Error('Invalid response format');
            }
            
            console.log('Items array:', items.length, items);
            
            items.forEach(item => {
                const option = document.createElement('option');
                option.value = item.id;
                
                // Truncate long item names for display
                let displayName = `${item.id} - ${item.name}`;
                if (displayName.length > 50) {
                    displayName = displayName.substring(0, 47) + '...';
                }
                option.textContent = displayName;
                option.title = `${item.id} - ${item.name}`; // Full name in tooltip
                itemSelector.appendChild(option);
            });
            
            itemSelector.disabled = false;
            console.log('Items loaded successfully, selector enabled');
        } catch (error) {
            console.error('Error loading items:', error);
        }
    }

    // Demo functions (temporary)
    async function loadDemoSingleSample() {
        try {
            const response = await fetch('/api/demo/single-sample', {
                method: 'GET',
                credentials: 'include'
            });
            
            if (!response.ok) {
                throw new Error('ë°ëª¨ ìƒ˜í”Œ íŒŒì¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
            }
            
            const data = await response.json();
            
            // Create a virtual file object from the content
            const blob = new Blob([data.content], { type: 'text/html' });
            const file = new File([blob], data.filename, { type: 'text/html' });
            
            // Simulate file drop for single report section
            // Find the first action's file input and simulate upload
            const firstAction = document.querySelector('.vectorcast-action[data-index="0"]');
            if (firstAction) {
                const fileInput = firstAction.querySelector('.action-file-input');
                const fileName = firstAction.querySelector('.action-file-name');
                
                // Create a DataTransfer object to simulate file selection
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInput.files = dataTransfer.files;
                
                // Trigger the file change handler
                handleActionFileChange(0);
            }
            
        } catch (error) {
            const statusElement = document.getElementById('vectorcastStatus');
            showStatus(statusElement, `ë°ëª¨ ë¡œë“œ ì‹¤íŒ¨: ${error.message}`, false);
            console.error('Error loading demo single sample:', error);
        }
    }

    async function loadDemoMultipleSamples() {
        try {
            const response = await fetch('/api/demo/multiple-samples', {
                method: 'GET',
                credentials: 'include'
            });
            
            if (!response.ok) {
                throw new Error('ë°ëª¨ ìƒ˜í”Œ íŒŒì¼ë“¤ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
            }
            
            const data = await response.json();
            const samples = data.samples;
            
            // Create virtual file objects from the content
            const files = samples.map(sample => {
                const blob = new Blob([sample.content], { type: 'text/html' });
                return new File([blob], sample.filename, { type: 'text/html' });
            });
            
            // Simulate multiple file drop
            handleMultipleFiles(files);
            
        } catch (error) {
            const statusElement = document.getElementById('multipleVectorcastStatus');
            showStatus(statusElement, `ë°ëª¨ ë¡œë“œ ì‹¤íŒ¨: ${error.message}`, false);
            console.error('Error loading demo multiple samples:', error);
        }
    }

</script>

</body>
</html>
